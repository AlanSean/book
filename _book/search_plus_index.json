{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction powered by Gitbook该文件修订时间： 2021-01-22 17:08:39 "},"1-clutter/":{"url":"1-clutter/","title":"Clutter","keywords":"","body":"clutter powered by Gitbook该文件修订时间： 2021-01-25 09:48:54 "},"1-clutter/gather.html":{"url":"1-clutter/gather.html","title":"Gather","keywords":"","body":"gather 目的 **搜集一些不错的特效，过渡动画，用来学习以及使用。** **来源均为网站扒取，会附上来源网站。** **尽量做到只取精华。** Power -------- canvas粉末效果 预览地址 来源渠道: 剑灵游戏活动看到，进行扒取的。我是来源地址 billboard-------- 宣传logo效果 预览地址 来源渠道: 搜索动画效果 无意间看到的 。并做了一些改动。 我是来源地址 我是源码地址 powered by Gitbook该文件修订时间： 2021-01-25 09:49:20 "},"1-clutter/serviceWorker配置.html":{"url":"1-clutter/serviceWorker配置.html","title":"ServiceWorker配置","keywords":"","body":"serviceWorker配置~要素 以及注意点 更新机制 注册的文件产生变动,触发install cache.addAll完成后不会主动触发skipWaiting skipWaiting触发方式 1.打开控制台手点 2.self.skipWaiting(); 缓存名称维护与替换,以及为什么这么做 代码更新 缓存名称也必须跟着变更 否则不会更新缓存 如果你只修改了缓存名称但是不进行删除，那么它会一辈子只用老的缓存 fetch 永远都比 install activate要先触发 在提交了迭代之后，最少要刷新两次才可能是最新版本（目前是刷第二次就是最新版本） 第一次刷新 是安装新的缓存 当前页面读取老的缓存，切换路由，新的页面 都为新的缓存。 第二次刷新 新的 新的 都是新的。 powered by Gitbook该文件修订时间： 2021-01-25 09:49:24 "},"2-ios调试/":{"url":"2-ios调试/","title":"Ios调试","keywords":"","body":"clutter powered by Gitbook该文件修订时间： 2021-01-25 09:49:04 "},"3-javascript记录/":{"url":"3-javascript记录/","title":"Javascript记录","keywords":"","body":"Javascript记录 powered by Gitbook该文件修订时间： 2021-01-25 10:27:34 "},"3-javascript记录/浅拷贝与深拷贝.html":{"url":"3-javascript记录/浅拷贝与深拷贝.html","title":"浅拷贝与深拷贝","keywords":"","body":"浅拷贝与深拷贝 powered by Gitbook该文件修订时间： 2019-11-28 16:07:15 "},"4-linux/":{"url":"4-linux/","title":"Linux","keywords":"","body":"clutter powered by Gitbook该文件修订时间： 2021-01-25 09:49:13 "},"4-linux/git安装.html":{"url":"4-linux/git安装.html","title":"Git安装","keywords":"","body":"linux 7.2 下 git安装 yum -y install git 安装目录在 /usr/libexec/git-core 但是这个方法安装的git版本比较低 源码安装 1.查询最新包版本 git 包地址 https://github.com/git/git/releases 想下载哪个版本只需要替换后面的版本号 https://codeload.github.com/git/git/tar.gz/v2.30.0 2.下载 wget https://codeload.github.com/git/git/tar.gz/v2.30.0 3.解压 tar -zxvf git-2.30.0.tar.gz 4.拿到解压后的源码以后我们需要编译源码了，不过在此之前需要安装编译所需要的依赖。 yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker 卸载安装的git yun -y remove git 5.编译git源码，进入 cd git-2.30.0 目录 make prefix=/usr/local/git all make prefix=/usr/local/git install 添加环境变量vi /etc/profile 最后一行添加 export PATH=$PATH:/usr/local/git/bin :wq //保存并退出 刷新变量 source /etc/profile powered by Gitbook该文件修订时间： 2021-01-21 16:04:19 "},"4-linux/http2升级.html":{"url":"4-linux/http2升级.html","title":"Http2升级","keywords":"","body":"http2升级 学习地址 下载最新版的OpenSSL 库 wget https://www.openssl.org/source/openssl-1.1.0f.tar.gz tar xzf openssl-1.1.0f.tar.gz cd openssl-1.1.0f ./config --prefix=/usr/local/openssl make && make install 替换openssl版本库 mv /usr/bin/openssl /usr/bin/openssl.old \\ mv /usr/include/openssl /usr/include/openssl.old \\ ln -s /usr/local/openssl/bin/openssl /usr/bin/openssl \\ ln -s /usr/local/openssl/include/openssl /usr/include/openssl \\ #链接新库文件 ln -s /usr/local/openssl/lib/libssl.so /usr/local/lib64/libssl.so \\ ln -s /usr/local/openssl/lib/libcrypto.so /usr/local/lib64/libcrypto.so \\ #检查更新后的openssl依赖库是否是1.1.0f strings /usr/local/lib64/libssl.so | grep OpenSSL #显示结果表明已升级到最新版本链接库 OpenSSL 1.1.0f 25 May 2017 #配置openssl库文件的搜索路径 echo '/usr/local/openssl/lib' >> /etc/ld.so.conf #使修改后的搜索路径生效 ldconfig -v #查看openssl版本，结果显示升级成功 openssl version OpenSSL 1.1.0f 25 May 2017 linux把nginx添加到全局环境变量 ln -s /usr/local/nginx/sbin/nginx /usr/local/bin/ /usr/local/bin/就是环境变量目录 nginx 编译 wget http://nginx.org/download/nginx1.13.7.tar.gz tar zxvf nginx1.13.7.tar.gz cd nginx1.13.7 ./configure --prefix=/usr/local/nginx \\ --conf-path=/usr/local/nginx/conf/nginx.conf \\ --sbin-path=/usr/local/nginx/sbin/nginx \\ #注意改成自己的pid文件位置 --pid-path=/usr/local/nginx/logs/nginx.pid \\ #注意改成自己的log文件位置 --error-log-path=/usr/local/nginx/logs/error.log \\ --http-log-path=/usr/local/nginx/logs/access.log \\ --user=nginx \\ --group=nginx \\ --with-http_ssl_module \\ --with-http_realip_module \\ --with-http_flv_module \\ --with-http_mp4_module \\ --with-http_gunzip_module \\ --with-http_gzip_static_module \\ --with-http_secure_link_module \\ --with-http_v2_module \\ --with-http_stub_status_module \\ --with-http_sub_module \\ #注意改成自己的openssl位置 --with-openssl=/usr/local/openssl-1.1.0f make mv /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.old cp objs/nginx /usr/local/nginx/sbin/nginx make upgrade nginx -V conf 文件 listen 443 ssl http2; powered by Gitbook该文件修订时间： 2019-11-28 16:07:15 "},"4-linux/lnmp/安装.html":{"url":"4-linux/lnmp/安装.html","title":"安装","keywords":"","body":"安装 运行 screen -S lnmp 如果提示screen: command not found 命令不存在可以执行：yum install screen 或 apt-get install screen安装， wget http://soft.vpser.net/lnmp/lnmp1.7.tar.gz -cO lnmp1.7.tar.gz && tar zxf lnmp1.7.tar.gz && cd lnmp1.7 && ./install.sh lnmp powered by Gitbook该文件修订时间： 2021-01-22 10:21:57 "},"4-linux/mongoDB.html":{"url":"4-linux/mongoDB.html","title":"MongoDB","keywords":"","body":"mongoDB安装 下载 wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-4.0.5.tgz 解压 tar -zxvf mongodb-linux-x86_64-4.0.5.tgz 改名 mv mongodb-linux-x86_64-4.0.5 你安装的目录/mongodb 环境变量 export PATH=/usr/local/mongodb/bin:$PATH ln -s /你安装的目录/mongodb/bin/mongod /usr/local/bin/mongod mkdir data cd data mkdir db mkdir logs vi logs/mongodb.log 按esc 输入:wq 回车 vi mongodb.conf #设置端口 port = 27017 #数据目录 dbpath = /你安装的目录/mongodb/data #日志目录 logpath = /你安装的目录/mongodb/data/logs/mongodb.log #后台运行 fork = true #日志输出方式 logappend = true #修改ip bind_ip = 0.0.0.0 #开启验证 auth = true 按esc 输入:wq 回车 进入mongo shell ./bin/mongo use admin db.createUser({user:'admin',pwd:\"密码你自己设置嘛\",roles:[\"root\"]}) 成功之后Ctrl+c 退出shell mongod -f /你安装的目录/mongodb/mongodb.conf 然后就可以在Robo里面访问拉，记住你得密码！！！ powered by Gitbook该文件修订时间： 2019-11-28 16:07:15 "},"4-linux/mysql.html":{"url":"4-linux/mysql.html","title":"Mysql","keywords":"","body":"安装 cd ~/lnmp1.7 ./install db 开启远程访问 登录 mysql -u root -p 查看用户表 use mysql select Host,User from user; grant all privileges on 库名.表名 to '用户名'@'IP地址' identified by '密码' with grant option; flush privileges; 库名:要远程访问的数据库名称,所有的数据库使用“” 表名:要远程访问的数据库下的表的名称，所有的表使用“” 用户名:要赋给远程访问权限的用户名称 IP地址:可以远程访问的电脑的IP地址，所有的地址使用“%” 密码:要赋给远程访问权限的用户对应使用的密码 增加新用户。（注意：mysql环境中的命令后面都带一个分号作为命令结束符） grant select on 数据库.* to 用户名@登录主机 identified by \"密码\" 如增加一个用户test密码为123，让他可以在任何主机上登录， 并对所有数据库有查询、插入、修改、删除的权限。首先用以root用户连入mysql，然后键入以下命令： grant select,insert,update,delete on . to \" Identified by \"123\"; 查询时区 show variables like '%time_zone%'; powered by Gitbook该文件修订时间： 2021-01-22 11:28:19 "},"4-linux/nginx.html":{"url":"4-linux/nginx.html","title":"Nginx","keywords":"","body":"server { listen 80; server_name book.hqboke.cn; location /{ root /home/book/; index index.html index.htm; } error_page 404 500 502 503 504 /50x.html; return 301 https://$server_name$request_uri; } server { listen 443 ssl; server_name book.hqboke.cn hqboke.cn; #填写绑定证书的域名 server_name_in_redirect off; ssl_certificate ssl/hqboke/1_book.hqboke.cn_bundle.crt; ssl_certificate_key ssl/hqboke/2_book.hqboke.cn.key; ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #按照这个协议配置 ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;#按照这个套件配置 ssl_prefer_server_ciphers on; root /home/book/; location ~*\\.(js|css|png|jpg|jpeg|gif|ico)$ { expires 30d; add_header Pragma public; add_header Cache-Control \"public\"; } location /{ root /home/book/; index index.php index.html index.htm; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Connection close; proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504; proxy_max_temp_file_size 0; proxy_connect_timeout 90; proxy_send_timeout 90; proxy_read_timeout 90; proxy_buffer_size 4k; proxy_buffers 4 32k; proxy_busy_buffers_size 64k; proxy_temp_file_write_size 64k; } } powered by Gitbook该文件修订时间： 2021-01-22 16:20:28 "},"4-linux/node安装.html":{"url":"4-linux/node安装.html","title":"Node安装","keywords":"","body":"node安装 ``` wget https://npm.taobao.org/mirrors/node/v8.9.3/node-v8.9.3-linux-x64.tar.xz yum search xz 检查是否有xz命令 yum install xz xz -d node-v8.9.3-linux-x64.tar.xz tar -xf node-v8.9.3-linux-x64.tar ln -s 安装的位置/node/bin/npm /usr/local/bin/npm ln -s 安装的位置/node/bin/node /usr/local/bin/node ``` powered by Gitbook该文件修订时间： 2019-11-28 16:07:15 "},"4-linux/nvm.html":{"url":"4-linux/nvm.html","title":"Nvm","keywords":"","body":"nvm下载慢 NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node powered by Gitbook该文件修订时间： 2021-01-21 16:07:53 "},"4-linux/命令.html":{"url":"4-linux/命令.html","title":"命令","keywords":"","body":"user www www; worker_processes auto; worker_cpu_affinity auto; error_log /home/wwwlogs/nginx_error.log crit; pid /usr/local/nginx/logs/nginx.pid; Specifies the value for maximum file descriptors that can be opened by this process. worker_rlimit_nofile 51200; events { use epoll; worker_connections 51200; multi_accept off; accept_mutex off; } http { include mime.types; default_type application/octet-stream; server_names_hash_bucket_size 128; client_header_buffer_size 32k; large_client_header_buffers 4 32k; client_max_body_size 50m; sendfile on; sendfile_max_chunk 512k; tcp_nopush on; keepalive_timeout 60; tcp_nodelay on; fastcgi_connect_timeout 300; fastcgi_send_timeout 300; fastcgi_read_timeout 300; fastcgi_buffer_size 64k; fastcgi_buffers 4 64k; fastcgi_busy_buffers_size 128k; fastcgi_temp_file_write_size 256k; gzip on; gzip_min_length 1k; gzip_buffers 4 16k; gzip_http_version 1.1; gzip_comp_level 2; gzip_types text/plain application/javascript application/x-javascript text/javascript text/css application/xml application/xml+rss; gzip_vary on; gzip_proxied expired no-cache no-store private auth; gzip_disable \"MSIE [1-6]\\.\"; #limit_conn_zone $binary_remote_addr zone=perip:10m; ##If enable limit_conn_zone,add \"limit_conn perip 10;\" to server section. server_tokens off; access_log off; server { listen 80 default_server reuseport; #listen [::]:80 default_server ipv6only=on; server_name _; index index.html index.htm index.php; root /home/hqboke/default; #error_page 404 /home/hqboke/404.html; # Deny access to PHP files in specific directory #location ~ /(wp-content|uploads|wp-includes|images)/.*\\.php$ { deny all; } include enable-php.conf; location /nginx_status { stub_status on; access_log off; } location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$ { expires 30d; } location ~ .*\\.(js|css)?$ { expires 12h; } location ~ /.well-known { allow all; } location ~ /\\. { deny all; } access_log /home/hqboke/access.log; } } powered by Gitbook该文件修订时间： 2021-01-22 14:24:34 "},"4-linux/外网问题.html":{"url":"4-linux/外网问题.html","title":"外网问题","keywords":"","body":"执行命令即可 iptables -F; iptables -t nat -F; iptables-save > /etc/sysconfig/iptables powered by Gitbook该文件修订时间： 2019-11-28 16:07:15 "},"5-puppeteer/":{"url":"5-puppeteer/","title":"Puppeteer","keywords":"","body":"clutter powered by Gitbook该文件修订时间： 2021-01-25 10:28:15 "},"5-puppeteer/安装.html":{"url":"5-puppeteer/安装.html","title":"安装","keywords":"","body":"cnpm i puppeteer -g powered by Gitbook该文件修订时间： 2019-11-28 16:07:15 "},"6-vuessr从0开始/":{"url":"6-vuessr从0开始/","title":"Vuessr从0开始","keywords":"","body":"clutter powered by Gitbook该文件修订时间： 2021-01-25 10:28:20 "},"6-vuessr从0开始/vue-server-renderer.html":{"url":"6-vuessr从0开始/vue-server-renderer.html","title":"Vue Server Renderer","keywords":"","body":"前言 上一次做了路由的相关配置，原本计划今天要做vuex部分，但是想了想，发现vuex单独的客户端部分穿插解释起来很麻烦，所以今天改做服务端部分。 服务端部分做完，再去做vuex的部分，这样就会很清晰。 vue ssr是分两个端，一个是客户端，一个是服务端。 所以要做两个cli3的配置。 那么下面就直接开始做吧。 修改package.json的命令 //package.json :client代表客户端 :server代表服务端 //使用VUE_NODE来作为运行环境是node的标识 //cli3内置 命令 --no-clean 不会清除dist文件 \"scripts\": { \"serve:client\": \" vue-cli-service serve\", \"build\":\"npm run build:server -- --silent && npm run build:client -- --no-clean --silent\", \"build:client\": \"vue-cli-service build\", \"build:server\": \"cross-env VUE_NODE=node vue-cli-service build\", \"start:server\": \"cross-env NODE_ENV=production nodemon nodeScript/index\" } 修改vue.config.js配置 添加完相关脚本命令之后，我们开始改造cli3配置。 首先要require('vue-server-renderer') 然后再根据VUE_NODE环境变量来决定编译的走向以及生成不同的环境清单 先做cli3服务端的入口文件 // src/entry/server.js import { createApp } from '../main.js' export default context => { return new Promise((resolve, reject) => { const { app, router } = createApp(context.data) //根据node传过来的路由 来调用router路由的指向 router.push(context.url) router.onReady(() => { //获取当前路由匹配的组件数组。 const matchedComponents = router.getMatchedComponents() //长度为0就是没找到该路由所匹配的组件 //可以路由设置重定向或者传回node node来操作也可以 if (!matchedComponents.length) { return reject({ code: 404 }) } resolve(app) }, reject) }) } 这里是cli3的配置 //vue.config.js const ServerPlugin = require('vue-server-renderer/server-plugin'),//生成服务端清单 ClientPlugin = require('vue-server-renderer/client-plugin'),//生成客户端清单 nodeExternals = require('webpack-node-externals'),//忽略node_modules文件夹中的所有模块 VUE_NODE = process.env.VUE_NODE === 'node', entry = VUE_NODE ? 'server' : 'client';//根据环境变量来指向入口 module.exports = { css: { extract: false//关闭提取css,不关闭 node渲染会报错 }, configureWebpack: () => ({ entry: `./src/entry/${entry}`, output: { filename: 'js/[name].js', chunkFilename: 'js/[name].js', libraryTarget: VUE_NODE ? 'commonjs2' : undefined }, target: VUE_NODE ? 'node' : 'web', externals: VUE_NODE ? nodeExternals({ //设置白名单 whitelist: /\\.css$/ }) : undefined, plugins: [//根据环境来生成不同的清单。 VUE_NODE ? new ServerPlugin() : new ClientPlugin() ] }), chainWebpack: config => { config.resolve .alias .set('vue$', 'vue/dist/vue.esm.js') config.module .rule('vue') .use('vue-loader') .tap(options => { options.optimizeSSR = false; return options; }); config.module .rule('images') .use('url-loader') .tap(options => { options = { limit: 1024, fallback:'file-loader?name=img/[path][name].[ext]' } return options; }); } } node相关配置 用于node渲染 必然要拦截get请求的。然后根据get请求地址来进行要渲染的页面。 官方提供了vue-server-renderer插件 大概的方式就是 node拦截所有的get请求，然后讲获取到的路由地址，传给前台，然后使用router实例进行push 再往下面看之前 先看一下官方文档 创建BundleRenderer createBundleRenderer 将 Vue 实例渲染为字符串。 renderToString 渲染应用程序的模板 template 生成所需要的客户端或服务端清单 clientManifest 先创建 服务端所需要的模板 //public/index.nodeTempalte.html vuessr node部分 先创建三个文件 index.js //入口 proxy.js //代理 server.js //主要配置 //server.js const fs = require('fs'); const { resolve } = require('path'); const express = require('express'); const app = express(); const proxy = require('./proxy'); const { createBundleRenderer } = require('vue-server-renderer') //模板地址 const templatePath = resolve(__dirname, '../public/index.nodeTempalte.html') //客户端渲染清单 const clientManifest = require('../dist/vue-ssr-client-manifest.json') //服务端渲染清单 const bundle = require('../dist/vue-ssr-server-bundle.json') //读取模板 const template = fs.readFileSync(templatePath, 'utf-8') const renderer = createBundleRenderer(bundle,{ template, clientManifest, runInNewContext: false }) //代理相关 proxy(app); //请求静态资源相关配置 app.use('/js', express.static(resolve(__dirname, '../dist/js'))) app.use('/css', express.static(resolve(__dirname, '../dist/css'))) app.use('/font', express.static(resolve(__dirname, '../dist/font'))) app.use('/img', express.static(resolve(__dirname, '../dist/img'))) app.use('*.ico', express.static(resolve(__dirname, '../dist'))) //路由请求 app.get('*', (req, res) => { res.setHeader(\"Content-Type\", \"text/html\") //传入路由 src/entry/server.js会接收到 使用vueRouter实例进行push const context = { url: req.url } renderer.renderToString(context, (err, html) => { if (err) { if (err.url) { res.redirect(err.url) } else { res.status(500).end('500 | 服务器错误'); console.error(`${req.url}: 渲染错误 `); console.error(err.stack) } } res.status(context.HTTPStatus || 200) res.send(html) }) }) module.exports = app; //proxy.js const proxy = require('http-proxy-middleware'); function proxyConfig(obj){ return { target:'localhost:8081', changeOrigin:true, ...obj } } module.exports = (app) => { //代理开发环境 if (process.env.NODE_ENV !== 'production') { app.use('/js/main*', proxy(proxyConfig())); app.use('/*hot-update*',proxy(proxyConfig())); app.use('/sockjs-node',proxy(proxyConfig({ws:true}))); } } //index.js const app = require('./server') app.listen(8080, () => { console.log('\\033[42;37m DONE \\033[40;33m localhost:8080 服务已启动\\033[0m') }) 做完这一步之后，就可以预览基本的服务渲染了。 后面就只差开发环境的配置，以及到node数据的传递(vuex) npm run build npm run start:server 打开localhost:8080 F12 - Network - Doc 就可以看到内容 最终目录结构 |-- vuessr |-- .gitignore |-- babel.config.js |-- package-lock.json |-- package.json |-- README.md |-- vue.config.js |-- nodeScript //node 渲染配置 | |-- index.js | |-- proxy.js | |-- server.js |-- public//模板文件 | |-- favicon.ico | |-- index.html | |-- index.nodeTempalte.html |-- src |-- App.vue |-- main.js |-- router.config.js/。路由集合 |-- store.config.js//vuex 集合 |-- assets//全局静态资源源码 | |-- 备注.txt | |-- img | |-- logo.png |-- components//全局组件 | |-- Head | |-- index.js | |-- index.scss | |-- index.vue | |-- img | |-- logo.png |-- entry//cli3入口 | |-- client.js | |-- server.js | |-- 备注.txt |-- methods//公共方法 | |-- 备注.txt | |-- mixin | |-- index.js |-- pages//源码目录 | |-- home | | |-- index.js | | |-- index.scss | | |-- index.vue | | |-- img | | | |-- flow.png | | | |-- head_portrait.jpg | | | |-- logo.png | | | |-- vuessr.png | | |-- vue | | | |-- index.js | | | |-- index.scss | | | |-- index.vue | | |-- vueCli3 | | | |-- index.js | | | |-- index.scss | | | |-- index.vue | | |-- vueSSR | | | |-- index.js | | | |-- index.scss | | | |-- index.vue | | |-- vuex | | |-- index.js | | |-- index.scss | | |-- index.vue | |-- router//路由配置 | | |-- index.js | |-- store//vuex配置 | |-- all.js | |-- gather.js | |-- index.js |-- static//cdn资源 |-- 备注.txt 项目github地址 项目公网地址 powered by Gitbook该文件修订时间： 2019-11-28 16:07:15 "},"6-vuessr从0开始/vuex.html":{"url":"6-vuessr从0开始/vuex.html","title":"Vuex","keywords":"","body":"vuex的相关配置 上一章做了node以及vue-cli3的配置,今天就来做vuex的部分。 先打开官方文档-数据预取和状态 看完之后，发现大致的逻辑就是 利用mixin，拦截页面渲染完成之前，查看当前实例是否含有'asyncData'函数(由你创建以及任意名称)， 如果含有就进行调用，并且传入你需要的对象比如(store,route) 例子 // pages/vuex/index.js export default { name: \"vuex\", asyncData({ store, route }) { // 触发 action 后，会返回 Promise return store.dispatch('fetchItem', route.path) }, computed: { // 从 store 的 state 对象中的获取 item。 item() { return this.$store.state.items[this.$route.path] } } } //mixin import Vue from 'vue'; Vue.mixin({ beforeMount() { const { asyncData } = this.$options if (asyncData) { this.dataPromise = asyncData({ store: this.$store, route: this.$route }) } } }) 上面只是个大概的示例，下面开始正式来做吧。 先创建一些文件 src/store.config.js 跟router.config.js 一样，在服务端运行避免状态单例 src/pages/store/all.js 全局公共模块 // src/pages/store/all.js const all = { //开启命名空间 namespaced: true, //ssr注意事项 state 必须为函数 state: () => ({ count:0 }), mutations: { inc: state => state.count++ }, actions: { inc: ({ commit }) => commit('inc') } } export default all; vuex 模块 all 单独一个全局模块 如果home有自己的数据，那么就在home下 惰性注册模块 但是记得页面销毁时，也一定要销毁模块！！！ 因为当多次访问路由时，可以避免在客户端重复注册模块。 如果想只有个别几个路由共用一个模块， 可以在all里面进行模块嵌套，或者将这个几个页面归纳到一个父级路由下 ，在父级实例进行模块惰性注册。 // home/index.js import all from '../store/all.js'; export default { name: 'home', computed:{ count(){ return this.$store.state.all.count } }, asyncData({ store}){ store.registerModule('all',all); return store.dispatch('all/inc') }, data() { return { activeIndex2: '1', show:false, nav:[ { path:'/home/vue', name:'vue' }, { path:'/home/vuex', name:'vue-vuex' }, { path:'/home/vueCli3', name:'vue-cli3' }, { path:'/home/vueSSR', name:'vue ssr' } ] }; }, watch:{ $route:function(){ if(this.show){ this.show = false; } //切换路由时，进行自增 this.$store.dispatch('all/inc'); } }, mounted() { //做额外请求时,在mounted下进行 }, methods: { user_info(){ this.http.post('/cms/i1/user_info').then(res=> { console.log(res.data); }).catch( error => { console.log(error) }) } }, destroyed(){ this.$store.unregisterModule('all') } } ` 数据预取 // store.config.js //store总配置 import Vue from 'vue'; import Vuex from 'vuex'; Vue.use(Vuex); //预请求数据 function fetchApi(id){ //该函数是运行在node环境 所以需要加上域名 return axios.post('http://localhost:8080/cms/i1/user_info'); } //返回 Vuex实例 避免在服务端运行时的单利状态 export function createStore() { return new Vuex.Store({ state:{ items:{} }, actions: { fetchItem ({commit}, id) { return fetchApi(id).then(item => { commit('setItem',{id, item}) }) } }, mutations: { setItem(state, {id, item}){ Vue.set(state.items, id, item.data) } } }) } mixin相关 在src下新建个methods 文件夹，这里存放写vue的全局代码以及配置 获取当前实例 // src/methods/index.js import './mixin'; import Vue from 'vue'; import axios from 'axios'; Vue.prototype.http = axios; // src/methods/mixin/index.js import Vue from 'vue'; Vue.mixin({ beforeMount() { const { asyncData } = this.$options;//这里 自己打印下就知道了。就不过多解释了 //当前实例是否有该函数 if (asyncData) { // 有就执行，并传入相应的参数。 asyncData({ store: this.$store, route: this.$route }) } } }) ` main.js 新增代码 import Vue from 'vue'; Vue.config.productionTip = false; import VueRouter from 'vue-router'; import App from './App.vue'; + import './methods'; //同步路由状态 + import { sync } from 'vuex-router-sync'; import { createRouter } from './router.config.js'; + import { createStore } from './store.config.js'; export function createApp() { const router = createRouter() const store = createStore() //同步路由状态(route state)到 store sync(store, router) const app = new Vue({ router, + store, render: h => h(App) }) return { app, router, + store }; } 项目github地址 项目公网地址 powered by Gitbook该文件修订时间： 2019-11-28 16:07:15 "},"6-vuessr从0开始/vue开发依赖的相关配置.html":{"url":"6-vuessr从0开始/vue开发依赖的相关配置.html","title":"Vue开发依赖的相关配置","keywords":"","body":"vue开发依赖的相关配置 Vue SSR 指南 今天先做客户端方面的配置，明天再做服务端的部分。 那么马上开始吧~ 修改部分代码 脚手架生成的代码肯定是不适合我们所用的 所以要修改一部分代码 //App.vue export default { name: 'app' } html,body,#app,#app>*{ width: 100%; height: 100%; } body{ font-family: 'Avenir', Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; font-size: 16px; margin: 0; overflow-x: hidden; } img{ width: 200px; } 修改main.js 为什么要这么做？为什么要避免状态单例 main.js 是我们应用程序的「通用 entry」。 在纯客户端应用程序中，我们将在此文件中创建根 Vue 实例，并直接挂载到 DOM。 但是，对于服务器端渲染(SSR)，责任转移到纯客户端 entry 文件。 main.js 简单地使用 export 导出一个 createApp 函数： import Vue from 'vue'; Vue.config.productionTip = false; import App from './App.vue'; //router store 实例 //这么做是避免状态单例 export function createApp() { const app = new Vue({ //挂载router，store render: h => h(App) }) //暴露app实例 return { app }; } 添加Vue.config.js配置 webpack的入口文件有两个，一个是客户端使用，一个是服务端使用。 为何这么做？ 今天只做客户端部分。 src/vue.config.js module.exports = { css: { extract: false//关闭提取css,不关闭 node渲染会报错 }, configureWebpack: () => ({ entry: './src/entry/client' }) } app.$mount('#app') 根目录创建 entry 文件夹，以及webpack入口代码 mdkir entry cd entry 创建 入口文件 client.js 作为客户端入口文件。 server,js 作为服务端端入口文件。 //先创建不做任何配置 entry/client.js import { createApp } from '../main.js'; const { app } = createApp(); app.$mount('#app'); 路由和代码分割 官方说明的已经很清楚了，我就不做过多介绍了，下面直接展示代码 添加新路由，这里将存放pages的相关路由 src/pages/router/index.js /** * * @method componentPath 路由模块入口 * @param {string} name 要引入的文件地址 * @return {Object} */ function componentPath (name = 'home'){ return { component:() => import(`../${name}/index.vue`) } } export default [ { path: '/home', ...componentPath(), children: [ { path: \"vue\", name: \"vue\", ...componentPath('home/vue') }, { path: \"vuex\", name: \"vuex\", ...componentPath('home/vuex') }, { path: \"vueCli3\", name: \"vueCli3\", ...componentPath('home/vueCli3') }, { path: \"vueSSR\", name: \"vueSSR\", ...componentPath('home/vueSSR') } ] } ] src/router.config.js作为路由的总配置 易于管理 //路由总配置 import Vue from 'vue'; import VueRouter from 'vue-router'; Vue.use(VueRouter); //为什么采用这种做法。 //如果以后有了别的大模块可以单独开个文件夹与pages平级 //再这里导入即可。这样易于管理 // pages import pages from './pages/router'; export function createRouter() { return new VueRouter({ mode: 'history', routes: [ { path: \"*\", redirect: '/home/vue' }, ...pages ] }) } 更新main.js import Vue from 'vue'; Vue.config.productionTip = false; import App from './App.vue'; + import { createRouter } from './router.config.js' //router store 实例 //这么做是避免状态单例 export function createApp() { + const router = createRouter() const app = new Vue({ + router, render: h => h(App) }) //暴露app,router实例 return { app, router }; } 更新 client.js 由于使用的路由懒加载，所以必须要等路由提前解析完异步组件，才能正确地调用组件中可能存在的路由钩子。 // client.js import { createApp } from '../main.js'; const { app, router } = createApp(); router.onReady( () => { app.$mount('#app'); }) vuex 明天再做 项目github地址 项目公网地址 powered by Gitbook该文件修订时间： 2019-11-28 16:07:15 "},"6-vuessr从0开始/伪热更新.html":{"url":"6-vuessr从0开始/伪热更新.html","title":"伪热更新","keywords":"","body":"伪热更新 上一期写了一些问题。 原计划是暂时不做处理的，最终结果就是今天没忍住鸭。 废话不多说先贴思路 1.先进行本地编译 2.编译完成后，利用chokidar分别监听源码文件以及编译后的文件。(源码改动，触发编译。编译后的文件发生改动，触发重载) 3.开启node服务 4.开启browserSync代理服务 用到的插件以及模块 npm //执行脚本命令 browser-sync //刷新浏览器的核心 chokidar //监听文件的修改 child_process //开启子进程 执行脚本 步骤1 直接使用npm对象执行写好的命令 function directives(commond,cb){ npm.load(function(){ //清除缓存 npm.commands.cache(['clean'], function(){ npm.commands.run([commond],cb); }) }) } //执行 npm run dev function dev(cb){ return directives('dev',function(){ cb && cb(); }) } 步骤2 chokidar可以监听文件。具体去看文档嘛 chokidar的change事件，只要你进行保存就会触发 不管你有没有发生改变。 //监听源码部分 //监听源码函数，发生改变 开启子进程 执行编译命令 function soundCode(cb){ console.log(`${num+=1}.chokidar开始监听src&public下的文件`) const warcher = .watch(['src/**/*.*','public/**/*.*']) warcher.on('all', (event, path) => { if(event ==='change'){ console.log('\\033[40;31m '+path+'源码发生修改，进行编译,请稍后'); //开启子进程并执行命令 child_process.exec('npm run dev',function(error, stdout, stderr){ if (error) { console.log(error.stack); console.log('Error code: '+error.code); console.log('Signal received: '+error.signal); } console.log(stdout); console.log('编译完成'); }) } }); console.log('\\033[40;32m 源码监听完成'); } // 监听编译后的代码（js）是否发生改变(不如说是进行保存) //监听distDev下的文件 编译后的代码 function compileCompleteCode(cb){ console.log(`${num+=1}.chokidar开始监听distDev下的文件`); //该文件产生变化时 说明构建已完成。 const watcher = chokidar.watch('distDev/**/*.js'); watcher.on('all', (event, path) => { if(event === 'change'){ console.log(path+'发生变化，开始进行热更新'); bs.reload(path); console.log('热更新已完成'); } }); console.log('\\033[40;32m 编译后的代码监听完成'); } 步骤3 directives('devServer'); 步骤4 bs.init({ proxy: 'http://localhost:8080', open: false }); 整体代码 const npm = require('npm'); const bs = require('browser-sync').create(); const chokidar = require('chokidar'); const child_process = require('child_process') var num = 0;//计数 function directives(commond,cb){ npm.load(function(){ npm.commands.cache(['clean'], function(){ npm.commands.run([commond],cb); }) }) } function dev(cb){ return directives('dev',function(){ cb && cb(); }) } //监听源码函数 function soundCode(cb){ console.log(`${num+=1}.chokidar开始监听src&public下的文件`) const warcher = chokidar.watch(['src/**/*.*','public/**/*.*']) warcher.on('all', (event, path) => { if(event ==='change'){ console.log('\\033[40;31m '+path+'源码发生修改，进行编译,请稍后'); child_process.exec('npm run dev',function(error, stdout, stderr){ if (error) { console.log(error.stack); console.log('Error code: '+error.code); console.log('Signal received: '+error.signal); } console.log(stdout); console.log('编译完成'); }) } }); console.log('\\033[40;32m 源码监听完成'); } //监听distDev下的文件 编译后的代码 function compileCompleteCode(cb){ console.log(`${num+=1}.chokidar开始监听distDev下的文件`); //该文件产生变化时 说明构建已完成。 const watcher = chokidar.watch('distDev/**/*.js'); watcher.on('all', (event, path) => { if(event === 'change'){ console.log(path+'发生变化，开始进行热更新'); bs.reload(path); console.log('热更新已完成'); } }); console.log('\\033[40;32m 编译后的代码监听完成'); } console.log(`${num+=1}.进行本地编译`); dev(function(){ console.log(\"\\033[40;31m 编译完成\") soundCode() compileCompleteCode() console.log(`${num+=1}开启node服务`) directives('devServer'); console.log(`${num+=1}开启browserSync代理服务`); bs.init({ proxy: 'http://localhost:8080', open: false }); }); 项目github地址 项目公网地址 powered by Gitbook该文件修订时间： 2019-11-28 16:07:15 "},"6-vuessr从0开始/准备.html":{"url":"6-vuessr从0开始/准备.html","title":"准备","keywords":"","body":"前言 前期需要准备的知识点。 阅读Vue SSR 指南 node部分 什么是commonjs2 node的fs模块 了解express或者其他基于node的web应用框架 反向代理 环境变量 vue-cli3部分 serve 和 build 的编译不同之处 chunks配置的问题 css配置 loader 添加与修改 output.libraryTarget target externals 前台部分 了解 vue vuex vue-router powered by Gitbook该文件修订时间： 2019-11-28 16:07:15 "},"6-vuessr从0开始/开发环境的部署.html":{"url":"6-vuessr从0开始/开发环境的部署.html","title":"开发环境的部署","keywords":"","body":"开发环境的部署 开发环境的部署，让我头疼了一阵子每次修改代码都要重新构建这样很麻烦，最终利用node脚本解决了这个问题。 思路 使用node执行脚本文件 调用 “npm命令” 来进行执行命令，然后监听需要监听的文件，发生改动时，则重新执行脚本。 效果就是代码改动保存时，就会进行重新构建，瑕疵就是无法自动刷新浏览器（思路已经想好了） 构建完成，或者代码改动构建完成时浏览器刷新 构建完成时，刷新浏览器的思路（这个我就不做了） 当完成构建利用WebSocket向前端发送通信然后执行reload。就实现了每次构建完成时刷新浏览器。 当前环境 判断 process.env.NODE_ENV即可。 实现代码 根目录创建bin // vuessr/bin/index.js var npm = require('npm'); //看不懂，就打印下npm 就懂了。 npm.load(function(){ //一定要清除。 npm.commands.cache(['clean'], function(){ npm.commands.run(['serve']) }); }) //package.json \"scripts\": { //node脚本执行的命令 \"serve\": \"npm run build && node nodeScript/index\", //开发环境服务 \"serve:client\": \"node nodeScript/index\", \"build\": \" npm run build:server -- --silent && npm run build:client -- --no-clean --silent\", //打包客户端代码 \"build:client\": \"vue-cli-service build\", //打包服务端使用的json \"build:server\": \"cross-env VUE_NODE=node vue-cli-service build\", //开发环境 \"start\": \"cross-env NODE_ENV=development nodemon bin/index\", //本地测试服务器的环境 \"start:server\": \"cross-env NODE_ENV=production nodemon nodeScript/index\", //服务器 \"pm2\": \" cross-env NODE_ENV=production pm2 start nodeScript/index.js --watch\" } vuessr到这里就完结了。 总结，坑很多，就不一一列举了。 瑕疵： 开发环境，代码修改时重新构建也会重启服务，暂时没有思路怎么只重新构建不重启服务。（不想开两个cmd窗口）。 问题来源： 开启node服务必须要等到代码构建完毕，否则node服务器是会报错，因为需要依赖代码构建完成后的json文件。 项目github地址 项目公网地址 powered by Gitbook该文件修订时间： 2019-11-28 16:07:15 "},"6-vuessr从0开始/开始.html":{"url":"6-vuessr从0开始/开始.html","title":"开始","keywords":"","body":"开始 初始化 npm install -g @vue/cli nodemon nodemon 检测目录文件更改时，来重启基于node开发的程序 vue create vuessr 我选的附带 babel,eslint cd vuessr 创建文件以及文件夹 type null > vue.config.js //node相关配置文件 mkdir nodeScript cd nodeScript type null > index.js type null > proxy.js type null > server.js 进入src目录 //目录初始化 cd ../src type null > router.config.js //路由配置 mkdir pages //项目展示页面主要目录 cd pages mkdir router mkdir entry //vue-cli3 entry的相关配置入口 vueSSR需要。 mkdir static/js //gulp提取框架,插件等几年不动的源码整合后存放于cdn服务器 mkdir static/css //gulp提取整合初始化的样式表，存放的位置 mkdie methods //vue等全局代码的存放比如拦截器 use mixin 兼容函数 //安装依赖 npm install --save-dev sass-loader npm-run-all npm运行多个命令 -s 是顺序 -p是并行 cross-env 可以修改node环境变量 webpack-node-externals 忽略node_modules文件夹中的所有模块 vue-server-renderer 不解释 修改eslint配置 package.json eslintConfig rules 这个对象下面添加，cli的eslint附带以下的配置 所以手动关闭下。 \"no-console\": 0, \"no-unused-vars\": 0, \"no-undef\": 0 如果你觉得eslint警告很烦，那么可以 vue.config.js module.exports = { ..., lintOnSave:false, ... } powered by Gitbook该文件修订时间： 2019-11-28 16:07:15 "},"7-WebSocket二进制数据传输/":{"url":"7-WebSocket二进制数据传输/","title":"WebSocket二进制数据传输","keywords":"","body":"clutter powered by Gitbook该文件修订时间： 2021-01-25 10:28:30 "},"7-webSocket二进制数据传输/UTF-16和UTF-8转Unicode.html":{"url":"7-webSocket二进制数据传输/UTF-16和UTF-8转Unicode.html","title":"UTF 16和UTF 8转Unicode","keywords":"","body":"前言 今天来学习UTF8转Unicode，UTF16转Unicode以达成UTF8,UTF16之间的互转。 提炼成函数的公式我并没有放出来，我的目的只是为了更加理解 字符编码之间的关系。 如果你需要转码方式，可以找其他的库，或者根据我文章来进行提炼。 基本利用按位操作符 符号运算符就可以完成。 今天这里只做UTF8转Unicode，UTF16转Unicode， 后续转换可以看前面的文章。 1.基础准备工作 2.Unicode转UTF16和UTF8 UTF16转Unicode 为了更好的理解，我们来使用上一期Unicode转UTF-16的结果 来进行UTF16转Unicode，U+22222转UTF-16 = [0xd848,0xde22] = '𢈢'(这个字的长度为二，所以要获取他所有的charCodeAt) function charCodeAt(str){ var length = str.length, num = 0, utf16Arr = []; for(num; num 计算utf-16 4字节的取值范围 上面代码获得了，这个字符的UTF-16编码数组，JS的字符串全部使用的UTF-16编码格式 回顾一下UTF-16的编码方式 将Unicode值减去0x10000,得到20位长的值，再将其分为高10位和低10位，分别为2个字节，高10位和低10位的范围都在 0 ~ 0x3FF，高10位加0xD800,低十位加0xDC00 首先我们先看字节问题，Unicode值在U+10000 ~ U+10FFFF时，会分为 两个2 字节,二进制 8位为一个字节,所以 UTF-16的四个字节的字符是两个 16位的二进制 并且根据UTF-16的编码方式的高位加0xD800 低位加0xDC00得出最小范围值 高10位最小值为0xD800，低10为最小值为0xDC00 再根据 高10位和低10位的范围都在 0 ~ 0x3FF得出最大范围值 高10位最大值为0xD800+0x3FF，低10为最大值为0xDC00+0x3FF 所以高10位的取值范围为 0xD800 ~ 0xdbff 低10位的取值范围为 高10位的取值范围为 0xDC00 ~ 0xdfff 我们已经得知了UTF16编码的高10位和低10位的取值范围所以可以进行判断 是否需要进行逆推转换 var strCode = charCodeAt('𢈢'), strCode0 = strCode[0], strCode1 = strCode[1]; if(strCode0 >= 0xD800 && strCode0 = 0xDC00 && strCode1 UTF8转Unicode 这里一样 使用上期例子运算出的结果[0xe4, 0xb8,0x80]进行转换 由于JS环境的字符串是UTF16编码所以我这里直接使用十六进制串来进行转换 怎么判断二进制数据的字符是utf8中的几字节 根据数据的第一个字节来进行判断 这个字符是几个字节。 根据表格找到编码规则,用来区分这个数据串的字符是几字节 js是使用小端存储的，小端存储是符合我们的逻辑，大端是逻辑相反 大小端模式 比如 小端存储是0xxx xxxx 大端存储就是相反的 xxxx xxx0 utf8编码规则 1 字节 0xxx xxxx 2 字节 110x xxxx 10xxxxxx 3 字节 1110 xxxx 10xxxxxx 10xxxxxx 4 字节 1111 0xxx 10xxxxxxx 10xxxxxx 10xxxxxx js是小端存储所以只需要按字节位进行对比即可。 utf8各字节编码规则鲜明差异比较大的是首个字节，所以只需要对比首个字节，就可得知是几个字节。 对比规则 根据 按位与的特性，将原码的x对应，编码规则的位值转为0其他位保持不变（若有更好的判断方法，非常期待您的留言） 也可以使用 带符号右移操作符 >>>（js并不会转换正负符号 所以可以进行放心使用） 对应编码规则右移n个位来进行判断值是否为0，110，1111。(只是猜想之一，并没有进行实际验证，目前仅实践了下面的方式) 推导过程 根据按位与用 1 来保留原码对应的编码规则位值以及x位值全部转换为0 来进行判断是几字节 二进制 将x替换为0 十六进制 1字节 char0 & 1xxx xxxx = 0xxx xxxx char0 & 1000 0000 = 0000 0000 char0 & 0x80 = 0 2字节 char0 & 111x xxxx = 110x xxxx char0 & 1110 0000 = 1100 0000 char0 & 0xE0 = 0xC0 3字节 char0 & 1111 xxxx = 1110 xxxx char0 & 1111 0000 = 1110 0000 char0 & 0xF0 = 0xE0 4字节 char0 & 1111 1xxx = 1111 0xxx char0 & 1111 1000 = 1111 0000 char0 & 0xF8 = 0xF0 上面的判断规则已经非常明了。 下面的转码 我就只进行三字节的转码规则，其他 若有兴趣，可自行参考3字节的方式进行推算（动手才是理解最好的方式） var buffer = new ArrayBuffer(6); var view = new DataView(buffer); view.setUint8(0,0xe4); view.setUint8(1,0xb8); view.setUint8(2,0x80); view.setUint8(3,0xe4); view.setUint8(4,0xb8); view.setUint8(5,0x80); //[[Uint8Array]]: Uint8Array(6) [228, 184, 128, 228, 184, 128] var byteOffset = 0,//起点从1开始 char0, length = view.byteLength;//获取数据的字节数 while(byteOffset > 12 = 4 >> 12 //00000000 00000000 00000000 00000100 >> 12 = 0100 0000 0000 0000 = 0x4000 = 16384 //第二自己后面有6个x 所以第二字节补6个0 //char1 >> 6 = 56 >> 12 //00000000 00000000 00000000 00111000 >> 6 = 1110 0000 0000 = 0xE00 = 3584 //第三字节为最后一个字节所以不需要末位补0 //利用按位或 进行组合 16384 | 3584 | 0 = 0100 1110 0000 0000 = 0x4e00 = 19968 //19968 这里编码转换就完成了。 powered by Gitbook该文件修订时间： 2019-11-28 16:07:15 "},"7-webSocket二进制数据传输/Unicode转UTF16与UTF8.html":{"url":"7-webSocket二进制数据传输/Unicode转UTF16与UTF8.html","title":"Unicode转UTF16与UTF8","keywords":"","body":"前言 今天学习一下编码，先回顾一下昨天的基础准备工作。 下面进行了解UTF-8与UTF-16的二进制编码方式。 为啥要了解这个，因为js中所有是string类型都是使用UTF-16编码的 因此我们与后端进行通信时，需要转换成与之一致的编码。（后端或者前端转换） UTF-8编码方式 注: 1. Unicode码范围 用十六进制表示 3. 8位二进制为一字节 Unicode码范围 UTF-8编码方式 占用字节 U+0000 ~ U+007F 0xxxxxxx 1 U+0080 ~ U+ 07FF 110xxxxx 10xxxxxx 2 U+0800 ~ U+FFFF 1110xxxx 10xxxxxx 10xxxxxx 3 U+10000 ~ U+10FFFF 11110xxx 10xxxxxxx 10xxxxxx 10xxxxxx 4 Unicode码转换UTF-8 Unicode编码表 使用，转换到UTF-8编码 在Unicode中汉字 “一”编码为U+4E00,\"丁\"编码为 U+4E01这样想必就看得懂表了 下面进行开始转换吧 回顾昨日的二进制与十六进制 U+4E00用十六进制表示 0x4E00 转换二进制，按位转换 4 = 0011 E = 14 = 1110 0 = 0000 0 = 0000 0x4E00 = 0100 1110 0000 0000 = 19968 0x0800> b 首位开始补 b 个 首位值 右侧舍去b个位 先舍去末6位 0100 1110 0000 0000 >> 6 = 000 000 0100 1110 00 19968 >> 6 = 312 利用按位与进行截取 000 000 0100 1110 00 & 111111 = 111 000 312 & 63 = 56 继续利用按位或进行变换 00 111000 | 10 000000 = 10 111000 56 | 128 = 184 第三字节 utf-8 3字节的第三字节编码方式为 1110 xxxx 所以只需要从第12开始截取4位 从末位第12位开始截取4位，利用带符号右移操作符 a >> b 首位开始补 b 个 首位值 右侧舍去b个位 0100 1110 0000 0000 >> 12 = 000 000 0000 0100 19968 >> 12 = 4 利用按位与进行截取 4位 二进制 1111 = 15 0100 & 1111 = 0100 4 & 15 = 4; 利用按位或进行变换 二进制 1110 0000 = 224 0000 0100 | 1110 0000 = 1110 0100 4 | 224 = 228 三个字节组合起来 228 184 128 = 1110 0100 1011 1000 1000 0000 = 14 4 11 8 8 0 utf-16转utf-8 0x4E00 = 0xe4b880 python编码转换 b'\\xe4\\xb8\\x80'.decode('utf-8') = \"一\" powered by Gitbook该文件修订时间： 2019-11-28 16:07:15 "},"7-webSocket二进制数据传输/字节算法准备基础.html":{"url":"7-webSocket二进制数据传输/字节算法准备基础.html","title":"字节算法准备基础","keywords":"","body":"二进制与十六进制 二进制用 0 1 表示 2= 10 十六进制 前缀0x 用0123456789ABCDEF表示 2= 0x2 二进制与十六进制的转换 十六进制的每位 等于二进制的四位 十六进制 0xF = 15(十进制) = 1111(二进制) 十六进制每位最大就是二进制的 1111 = 15(十进制) 二进制 2 = 10 十六进制 2 = 0x2 = 0010 规律很清晰了吧 20 = 10100(6位 口算得出要补齐8位) 0001 0100 0001 = 1 0100 = 4 20 = 0001 0100 = 0x14 二进制字节 一个字节是8个二进制位 0000 0000 - 1111 1111 = 0-255 代表一个字节可以表示256个符号 UTF编码字节 UTF-16 UTF-16大部分使用两个字节编码，编码超出 65535 的使用四个字节 0x0000 - 0xFFFF 两个字节 0x010000 - 0x10FFFF 四个字节 UTF-8 0x0000 - 0x007F 一个字节 0x0080 - 0x07FF 两个字节 0x0800 - 0xD7FF 、0xE000 - 0xFFFF 三个字节 0x010000 - 0x10FFFF 四个字节 注: Unicode在范围 D800-DFFF 中不存在任何字符 有符号32位整数节 所有的按位操作符的操作数都会被转成补码（two's complement）形式的有符号32位整数。 反码、补码 负数 js中的二进制转换是不会转换符号的 1的反码 补码 以及 -1 1 = 0000 0000 0000 0000 0000 0000 0000 0001 反码 1 =0、0 =1 下面会讲述按位操作符 按位非 ~ 其实就是反码 1111 1111 1111 1111 1111 1111 1111 1110 补码后 末位+1 1111 1111 1111 1111 1111 1111 1111 1111 = -1 按位操作符 按位操作符（Bitwise operators） 将其操作数（operands）当作32位的比特序列（由0和1组成），而不是十进制、十六进制或八进制数值。例如，十进制数9，用二进制表示则为1001。按位操作符操作数字的二进制形式，但是返回值依然是标准的JavaScript数值。 &、| 在转码中比较常用 按位与 & 1为真，0为假 全真则真 遇假为假 js 内置方法 var a = 1; a.toString(2); 十转二 2 = 10 3 = 11 二进制进行按位与运算 从左到右 1 && 1 = 1 0 && 1 = 0 2 & 3 = 10 = 2 按位或 | 1为真，0为假 遇真则真 全假为假 8 = 1000 9 = 1001 二进制按位或运算 从左到右 1 || 1 = 1 0 || 0 = 0 0 || 0 = 0 0 || 1 = 1 8 | 9 = 1001 = 9 按位异或 ^ 1为真，0为假。不同为真 相同为假 4 = 100 5 = 101 二进制按位异或运算 从左到右 1 1 = 0 0 0 = 0 0 1 = 1 4 ^ 5 = 001 = 1 按位非 ~ 1为真，0为假 对每一项进行非操作，遇真则假，遇假则真。（速算， ~x =-1*x-1） 6 = 00000000 00000000 00000000 00000110 11111111 11111111 11111111 11111001 = -7 按位移动操作符 有两个操作数 左侧为要被移动的数字(十进制，但是操作是内部对二进制操作) 右侧为移动的长度方向根据操作符移动，返回根据被操作数相同类型的结果，必须小于32位 左移操作符 a 11 = 00000000 00000000 00000000 00001011 11 带符号右移操作符( 记住左侧首位 0 代表正 ，1 代表负) >> a >> b 左侧首位开始补 b 个 首位值 右侧侧舍去b个位 12 = 00000000 00000000 00000000 00001100 12 >> 2 补 b 个 首位值 00 00000000 00000000 00000000 00001100 右侧舍去b个位 00 00000000 00000000 00000000 000011 格式化 00000000 00000000 00000000 00000011 = 3 -3 = (反码)11111111 11111111 11111111 11111100 (补码)11111111 11111111 11111111 11111101 -12 >> 2 -12 = (反码)11111111 11111111 11111111 11110011 (补码)11111111 11111111 11111111 11110100 -12 >> 2 补 b 个 首位值 11 11111111 11111111 11111111 11110100 右侧舍去b个位 11 11111111 11111111 11111111 111101 格式化 11111111 11111111 11111111 11111101 = -3 powered by Gitbook该文件修订时间： 2019-11-28 16:07:15 "},"8-随便写写/":{"url":"8-随便写写/","title":"随便写写","keywords":"","body":"clutter powered by Gitbook该文件修订时间： 2021-01-25 10:28:38 "},"8-随便写写/Browserslist详解.html":{"url":"8-随便写写/Browserslist详解.html","title":"Browserslist详解","keywords":"","body":"查询网址 (https://browserl.ist/) Browserslist配合的插件 Autoprefixer Babel postcss-preset-env eslint-plugin-compat stylelint-no-unsupported-browser-features postcss-normalize 浏览器列表 您可以通过查询指定浏览器和Node.js版本（不区分大小写）： > 5%：全球使用情况统计选择的浏览器版本。 >=， 5% in US：使用美国使用情况统计。它接受两个字母的国家/地区代码。 > 5% in alt-AS：使用亚洲地区使用情况统计。可在以下位置找到所有地区代码的列表caniuse-lite/data/regions。 > 5% in my stats：使用自定义使用数据。 cover 99.5%：提供覆盖的最流行的浏览器。 cover 99.5% in US：与上述相同，使用双字母国家代码。 cover 99.5% in my stats：使用自定义使用数据。 maintained node versions：所有Node.js版本，仍由 Node.js Foundation 维护。 node 10和node 10.4：选择最新的Node.js 10.x.x 或10.4.x发布。 current node：Browserslist目前使用的Node.js版本。 extends browserslist-config-mycompany：从browserslist-config-mycompanynpm包中获取查询 。 ie 6-8：选择包含范围的版本。 Firefox > 20：Firefox的版本比20更新 >=， 0.5%, last 2 versions, Firefox ESR, not dead）。 not ie powered by Gitbook该文件修订时间： 2021-01-22 17:22:37 "},"8-随便写写/element-ui.html":{"url":"8-随便写写/element-ui.html","title":"Element Ui","keywords":"","body":"element-ui 坑的记录 `安装过程看官网,我采用的是按需引入` element-ui Form 表单组件 下拉框选择与显示不符合 选择的options与实际点击的结果不符 el-select显示正确的选择条件是 el-select 的v-model 和 el-option 的value 必须是单一项，不能是数组或对象 powered by Gitbook该文件修订时间： 2021-01-22 17:22:38 "},"8-随便写写/git.html":{"url":"8-随便写写/git.html","title":"Git","keywords":"","body":"git 初始化配置 //全局global 本地 local git config --global --list 查看配置项 git config --global user.name 'xxx' git config --global user.email 'xxx' 免密码 ssh-keygen -t rsa -C \"这里换上你的邮箱\" 在指定的保存路径下会生成2个名为id_rsa和id_rsa.pub的文件： github 选择SSH and GPG keys 配置即可 删除某文件历史记录 删除文件在本地的提交历史: git filter-branch --force --index-filter 'git rm --cached --ignore-unmatch 文件地址' --prune-empty --tag-name-filter cat -- --all 将修改提交到远程仓库，远程仓库的commit历史将被修改 git push origin --force --all 如果tag中也需要删除敏感数据，则执行 git push origin --force --tags 取消合并 git merge --abort #如果Git版本 >= 1.7.4 git reset --merge #如果Git版本 >= 1.6.1 撤销commit git status git reset HEAD 文件名 取消文件的修改 git checkout -- 文件名 恢复单个文件 git log '文件路径' git checkout 'logid' '文件路径' powered by Gitbook该文件修订时间： 2021-01-22 17:22:40 "}}